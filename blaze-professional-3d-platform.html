<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blaze Sports Intel - Professional 3D Platform with Advanced Shaders</title>
    <meta name="description" content="Championship-grade sports analytics with professional 3D graphics, advanced shaders (Bloom, SSAO, Motion Blur), and Unity MCP integration">

    <!-- Advanced 3D Libraries -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;900&family=Orbitron:wght@400;700;900&display=swap');

        :root {
            --blaze-orange: #ff6b00;
            --blaze-dark: #0a0a0f;
            --blaze-darker: #050508;
            --blaze-blue: #00d4ff;
            --blaze-purple: #a855f7;
            --blaze-green: #10b981;
            --blaze-gold: #fbbf24;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background: var(--blaze-darker);
            color: #ffffff;
            overflow-x: hidden;
            line-height: 1.6;
        }

        /* Navigation */
        nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(10, 10, 15, 0.98);
            backdrop-filter: blur(20px);
            padding: 1rem 2rem;
            z-index: 1000;
            border-bottom: 2px solid var(--blaze-orange);
            box-shadow: 0 4px 20px rgba(255, 107, 0, 0.3);
        }

        .nav-content {
            max-width: 1800px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-family: 'Orbitron', monospace;
            font-size: 1.8rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--blaze-orange), var(--blaze-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(255, 107, 0, 0.5);
        }

        .nav-badge {
            background: linear-gradient(135deg, var(--blaze-purple), var(--blaze-blue));
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
        }

        /* Hero Section */
        .hero {
            height: 100vh;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #mainCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .hero-overlay {
            position: relative;
            z-index: 2;
            text-align: center;
            max-width: 1200px;
            padding: 2rem;
            background: rgba(10, 10, 15, 0.7);
            backdrop-filter: blur(20px);
            border-radius: 30px;
            border: 2px solid rgba(255, 107, 0, 0.5);
        }

        .hero-title {
            font-family: 'Orbitron', monospace;
            font-size: clamp(3rem, 8vw, 7rem);
            font-weight: 900;
            background: linear-gradient(135deg, #ffffff, var(--blaze-blue), var(--blaze-orange));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1rem;
            animation: titlePulse 3s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.02); filter: brightness(1.2); }
        }

        .hero-subtitle {
            font-size: clamp(1.2rem, 3vw, 2rem);
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 1.5rem;
        }

        .tech-badges {
            display: flex;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
            margin: 2rem 0;
        }

        .tech-badge {
            background: rgba(255, 107, 0, 0.2);
            border: 1px solid var(--blaze-orange);
            padding: 0.75rem 1.5rem;
            border-radius: 25px;
            font-size: 0.9rem;
            font-weight: 600;
            backdrop-filter: blur(10px);
        }

        .cta-group {
            display: flex;
            gap: 1.5rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 2rem;
        }

        .cta-btn {
            padding: 1.2rem 3rem;
            font-size: 1.1rem;
            font-weight: 700;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .cta-primary {
            background: linear-gradient(135deg, var(--blaze-orange), #ff8c00);
            color: white;
            box-shadow: 0 0 40px rgba(255, 107, 0, 0.6);
        }

        .cta-primary:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 50px rgba(255, 107, 0, 0.8);
        }

        .cta-secondary {
            background: rgba(0, 212, 255, 0.2);
            color: white;
            border: 2px solid var(--blaze-blue);
            backdrop-filter: blur(10px);
        }

        .cta-secondary:hover {
            background: rgba(0, 212, 255, 0.3);
            transform: translateY(-5px);
        }

        /* Section Container */
        .section {
            padding: 6rem 2rem;
            position: relative;
        }

        .section-dark {
            background: linear-gradient(180deg, var(--blaze-dark) 0%, var(--blaze-darker) 100%);
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        .section-header {
            text-align: center;
            margin-bottom: 4rem;
        }

        .section-title {
            font-family: 'Orbitron', monospace;
            font-size: clamp(2.5rem, 5vw, 4rem);
            font-weight: 900;
            background: linear-gradient(135deg, var(--blaze-orange), var(--blaze-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1rem;
        }

        .section-subtitle {
            font-size: 1.3rem;
            color: rgba(255, 255, 255, 0.7);
            max-width: 900px;
            margin: 0 auto;
        }

        /* Visualization Grid */
        .viz-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 3rem;
            margin-top: 3rem;
        }

        .viz-card {
            background: rgba(255, 255, 255, 0.02);
            border: 2px solid rgba(255, 107, 0, 0.3);
            border-radius: 25px;
            padding: 2.5rem;
            position: relative;
            overflow: hidden;
            transition: all 0.4s ease;
        }

        .viz-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 107, 0, 0.15), transparent);
            opacity: 0;
            transition: opacity 0.4s;
        }

        .viz-card:hover::before {
            opacity: 1;
        }

        .viz-card:hover {
            transform: translateY(-10px);
            border-color: var(--blaze-orange);
            box-shadow: 0 25px 60px rgba(255, 107, 0, 0.4);
        }

        .viz-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .viz-title {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--blaze-orange);
        }

        .viz-badge {
            background: linear-gradient(135deg, var(--blaze-blue), var(--blaze-purple));
            padding: 0.6rem 1.2rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
        }

        .viz-canvas {
            width: 100%;
            height: 500px;
            border-radius: 15px;
            background: rgba(0, 0, 0, 0.4);
            margin-bottom: 1.5rem;
            border: 1px solid rgba(255, 107, 0, 0.2);
        }

        .viz-controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .viz-btn {
            padding: 0.85rem 1.8rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 107, 0, 0.6);
            border-radius: 12px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            font-size: 0.95rem;
        }

        .viz-btn:hover {
            background: var(--blaze-orange);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(255, 107, 0, 0.4);
        }

        .viz-btn.active {
            background: var(--blaze-orange);
            border-color: var(--blaze-orange);
        }

        /* Shader Info Card */
        .shader-info {
            background: linear-gradient(135deg, rgba(255, 107, 0, 0.1), rgba(0, 212, 255, 0.1));
            border: 2px solid rgba(255, 107, 0, 0.3);
            border-radius: 20px;
            padding: 2rem;
            margin-top: 2rem;
        }

        .shader-info h4 {
            color: var(--blaze-blue);
            font-size: 1.3rem;
            margin-bottom: 1rem;
        }

        .shader-info ul {
            list-style: none;
            padding: 0;
        }

        .shader-info li {
            padding: 0.5rem 0;
            padding-left: 1.5rem;
            position: relative;
        }

        .shader-info li::before {
            content: '‚ñ∏';
            position: absolute;
            left: 0;
            color: var(--blaze-orange);
            font-weight: bold;
        }

        /* Performance Monitor */
        .performance-monitor {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: rgba(10, 10, 15, 0.95);
            border: 2px solid var(--blaze-orange);
            border-radius: 15px;
            padding: 1.5rem;
            min-width: 250px;
            backdrop-filter: blur(20px);
            z-index: 999;
        }

        .perf-title {
            color: var(--blaze-orange);
            font-weight: 700;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .perf-row {
            display: flex;
            justify-content: space-between;
            margin: 0.5rem 0;
            font-size: 0.9rem;
        }

        .perf-label {
            color: rgba(255, 255, 255, 0.7);
        }

        .perf-value {
            color: var(--blaze-blue);
            font-weight: 700;
        }

        .perf-value.good {
            color: var(--blaze-green);
        }

        .perf-value.warning {
            color: var(--blaze-gold);
        }

        /* Unity MCP Status */
        .mcp-status {
            background: rgba(168, 85, 247, 0.1);
            border: 2px solid var(--blaze-purple);
            border-radius: 15px;
            padding: 2rem;
            margin: 2rem 0;
        }

        .mcp-status h3 {
            color: var(--blaze-purple);
            margin-bottom: 1rem;
        }

        .mcp-badge {
            display: inline-block;
            background: var(--blaze-purple);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            margin: 0.5rem;
        }

        /* Footer */
        footer {
            background: var(--blaze-darker);
            padding: 4rem 2rem;
            border-top: 2px solid var(--blaze-orange);
        }

        .footer-content {
            max-width: 1800px;
            margin: 0 auto;
            text-align: center;
        }

        .footer-logo {
            font-family: 'Orbitron', monospace;
            font-size: 2.5rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--blaze-orange), var(--blaze-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 2rem;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .viz-grid {
                grid-template-columns: 1fr;
            }

            .performance-monitor {
                bottom: 1rem;
                right: 1rem;
                min-width: 200px;
            }
        }

        @media (max-width: 768px) {
            .hero-title {
                font-size: 3rem;
            }

            .section {
                padding: 3rem 1rem;
            }

            .viz-canvas {
                height: 350px;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav>
        <div class="nav-content">
            <div class="logo">üî• BLAZE PROFESSIONAL</div>
            <div class="nav-badge">Advanced Shaders ‚Ä¢ Unity MCP</div>
        </div>
    </nav>

    <!-- Hero Section with Babylon.js Advanced Rendering -->
    <section class="hero">
        <canvas id="mainCanvas"></canvas>
        <div class="hero-overlay">
            <h1 class="hero-title">PROFESSIONAL 3D</h1>
            <p class="hero-subtitle">Championship Sports Analytics with Advanced Shader Pipeline</p>

            <div class="tech-badges">
                <span class="tech-badge">‚ú® Bloom Post-Processing</span>
                <span class="tech-badge">üå´Ô∏è SSAO (Screen Space Ambient Occlusion)</span>
                <span class="tech-badge">üí´ Motion Blur</span>
                <span class="tech-badge">üé® Chromatic Aberration</span>
                <span class="tech-badge">üî• Rim Lighting</span>
                <span class="tech-badge">üéØ Depth of Field</span>
            </div>

            <div class="cta-group">
                <a href="#visualizations" class="cta-btn cta-primary">Explore Visualizations</a>
                <a href="#shaders" class="cta-btn cta-secondary">Shader Details</a>
            </div>
        </div>
    </section>

    <!-- Unity MCP Integration Status -->
    <section class="section">
        <div class="container">
            <div class="mcp-status">
                <h3>ü§ñ Unity MCP Integration Ready</h3>
                <p style="color: rgba(255,255,255,0.8); margin-bottom: 1rem;">
                    Real-time communication bridge between AI assistants and Unity Editor.
                    Manage scenes, assets, and scripts via natural language commands.
                </p>
                <div>
                    <span class="mcp-badge">Natural Language Control</span>
                    <span class="mcp-badge">Asset Management</span>
                    <span class="mcp-badge">Scene Control</span>
                    <span class="mcp-badge">Script Automation</span>
                    <span class="mcp-badge">Real-time Updates</span>
                </div>
            </div>
        </div>
    </section>

    <!-- Advanced 3D Visualizations -->
    <section class="section section-dark" id="visualizations">
        <div class="container">
            <div class="section-header">
                <h2 class="section-title">Professional-Grade Visualizations</h2>
                <p class="section-subtitle">
                    Advanced shader techniques from game development applied to sports analytics.
                    Bloom, SSAO, motion blur, and more for unparalleled visual clarity.
                </p>
            </div>

            <div class="viz-grid">
                <!-- Bloom Enhanced Stadium -->
                <div class="viz-card">
                    <div class="viz-header">
                        <h3 class="viz-title">‚ú® Bloom-Enhanced Stadium</h3>
                        <span class="viz-badge">Babylon.js + Bloom</span>
                    </div>
                    <canvas class="viz-canvas" id="bloomCanvas"></canvas>
                    <div class="viz-controls">
                        <button class="viz-btn active" onclick="setBloomIntensity(0.5)">Low Bloom</button>
                        <button class="viz-btn" onclick="setBloomIntensity(1.5)">Medium Bloom</button>
                        <button class="viz-btn" onclick="setBloomIntensity(3.0)">High Bloom</button>
                        <button class="viz-btn" onclick="toggleBloom()">Toggle On/Off</button>
                    </div>
                    <div class="shader-info">
                        <h4>üåü Bloom Shader Technique</h4>
                        <ul>
                            <li>Extracts bright areas above threshold</li>
                            <li>Applies Gaussian blur in multiple passes</li>
                            <li>Combines blurred glow with original scene</li>
                            <li>Creates realistic light bleeding effect</li>
                            <li>Performance: <strong>2ms overhead</strong></li>
                        </ul>
                    </div>
                </div>

                <!-- SSAO Enhanced Scene -->
                <div class="viz-card">
                    <div class="viz-header">
                        <h3 class="viz-title">üå´Ô∏è SSAO Player Analysis</h3>
                        <span class="viz-badge">Screen Space AO</span>
                    </div>
                    <canvas class="viz-canvas" id="ssaoCanvas"></canvas>
                    <div class="viz-controls">
                        <button class="viz-btn active" onclick="setSSAORadius(1.0)">Tight Radius</button>
                        <button class="viz-btn" onclick="setSSAORadius(3.0)">Medium Radius</button>
                        <button class="viz-btn" onclick="setSSAORadius(6.0)">Wide Radius</button>
                        <button class="viz-btn" onclick="toggleSSAO()">Toggle On/Off</button>
                    </div>
                    <div class="shader-info">
                        <h4>üé≠ SSAO (Screen Space Ambient Occlusion)</h4>
                        <ul>
                            <li>Calculates occlusion in screen space</li>
                            <li>Samples depth buffer for proximity</li>
                            <li>Adds contact shadows and depth perception</li>
                            <li>Enhances 3D realism dramatically</li>
                            <li>Performance: <strong>3ms overhead</strong></li>
                        </ul>
                    </div>
                </div>

                <!-- Motion Blur Pitch Tracking -->
                <div class="viz-card">
                    <div class="viz-header">
                        <h3 class="viz-title">üí´ Motion Blur Pitch Tracker</h3>
                        <span class="viz-badge">Velocity Buffer</span>
                    </div>
                    <canvas class="viz-canvas" id="motionBlurCanvas"></canvas>
                    <div class="viz-controls">
                        <button class="viz-btn active" onclick="setMotionBlur(0.5)">Subtle Blur</button>
                        <button class="viz-btn" onclick="setMotionBlur(1.0)">Medium Blur</button>
                        <button class="viz-btn" onclick="setMotionBlur(2.0)">Heavy Blur</button>
                        <button class="viz-btn" onclick="toggleMotionBlur()">Toggle On/Off</button>
                    </div>
                    <div class="shader-info">
                        <h4>‚ö° Motion Blur Technique</h4>
                        <ul>
                            <li>Renders velocity buffer for moving objects</li>
                            <li>Samples along velocity vector</li>
                            <li>Creates realistic motion streaks</li>
                            <li>Emphasizes high-speed movement</li>
                            <li>Performance: <strong>2.5ms overhead</strong></li>
                        </ul>
                    </div>
                </div>

                <!-- Rim Lighting Player Models -->
                <div class="viz-card">
                    <div class="viz-header">
                        <h3 class="viz-title">üî• Rim-Lit Player Models</h3>
                        <span class="viz-badge">Fresnel + Rim</span>
                    </div>
                    <canvas class="viz-canvas" id="rimCanvas"></canvas>
                    <div class="viz-controls">
                        <button class="viz-btn active" onclick="setRimColor('orange')">Orange Rim</button>
                        <button class="viz-btn" onclick="setRimColor('blue')">Blue Rim</button>
                        <button class="viz-btn" onclick="setRimColor('white')">White Rim</button>
                        <button class="viz-btn" onclick="toggleRim()">Toggle On/Off</button>
                    </div>
                    <div class="shader-info">
                        <h4>üí° Rim Lighting Shader</h4>
                        <ul>
                            <li>Uses Fresnel factor for edge detection</li>
                            <li>Calculates view-normal dot product</li>
                            <li>Applies colored glow at silhouette edges</li>
                            <li>Creates professional lighting separation</li>
                            <li>Performance: <strong>1ms overhead</strong></li>
                        </ul>
                    </div>
                </div>

                <!-- Depth of Field Focus -->
                <div class="viz-card">
                    <div class="viz-header">
                        <h3 class="viz-title">üéØ Depth of Field Analytics</h3>
                        <span class="viz-badge">DOF + Bokeh</span>
                    </div>
                    <canvas class="viz-canvas" id="dofCanvas"></canvas>
                    <div class="viz-controls">
                        <button class="viz-btn active" onclick="setDOFFocus(5)">Near Focus</button>
                        <button class="viz-btn" onclick="setDOFFocus(10)">Mid Focus</button>
                        <button class="viz-btn" onclick="setDOFFocus(20)">Far Focus</button>
                        <button class="viz-btn" onclick="toggleDOF()">Toggle On/Off</button>
                    </div>
                    <div class="shader-info">
                        <h4>üì∑ Depth of Field Technique</h4>
                        <ul>
                            <li>Reads depth buffer for distance</li>
                            <li>Applies Gaussian blur based on focal distance</li>
                            <li>Creates cinematic camera-like focus</li>
                            <li>Emphasizes specific players/areas</li>
                            <li>Performance: <strong>3.5ms overhead</strong></li>
                        </ul>
                    </div>
                </div>

                <!-- Chromatic Aberration Speed Lines -->
                <div class="viz-card">
                    <div class="viz-header">
                        <h3 class="viz-title">üé® Chromatic Aberration Effects</h3>
                        <span class="viz-badge">Color Separation</span>
                    </div>
                    <canvas class="viz-canvas" id="chromaticCanvas"></canvas>
                    <div class="viz-controls">
                        <button class="viz-btn active" onclick="setChromaticAmount(0.002)">Subtle</button>
                        <button class="viz-btn" onclick="setChromaticAmount(0.005)">Medium</button>
                        <button class="viz-btn" onclick="setChromaticAmount(0.01)">Strong</button>
                        <button class="viz-btn" onclick="toggleChromatic()">Toggle On/Off</button>
                    </div>
                    <div class="shader-info">
                        <h4>üåà Chromatic Aberration</h4>
                        <ul>
                            <li>Separates RGB channels radially</li>
                            <li>Samples red, green, blue at offset positions</li>
                            <li>Creates lens distortion effect</li>
                            <li>Adds cinematic quality to fast action</li>
                            <li>Performance: <strong>0.5ms overhead</strong></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Performance Monitor -->
    <div class="performance-monitor">
        <div class="perf-title">‚ö° Performance Monitor</div>
        <div class="perf-row">
            <span class="perf-label">FPS:</span>
            <span class="perf-value good" id="perfFPS">60</span>
        </div>
        <div class="perf-row">
            <span class="perf-label">Render Time:</span>
            <span class="perf-value good" id="perfRenderTime">12ms</span>
        </div>
        <div class="perf-row">
            <span class="perf-label">Draw Calls:</span>
            <span class="perf-value" id="perfDrawCalls">45</span>
        </div>
        <div class="perf-row">
            <span class="perf-label">Triangles:</span>
            <span class="perf-value" id="perfTriangles">125K</span>
        </div>
        <div class="perf-row">
            <span class="perf-label">Post-FX:</span>
            <span class="perf-value" id="perfPostFX">6 Active</span>
        </div>
    </div>

    <!-- Footer -->
    <footer>
        <div class="footer-content">
            <div class="footer-logo">üî• BLAZE PROFESSIONAL 3D</div>
            <p style="color: rgba(255,255,255,0.7); max-width: 900px; margin: 0 auto 2rem;">
                Professional-grade sports analytics with advanced shader techniques from game development.
                Bloom, SSAO, Motion Blur, Rim Lighting, Depth of Field, and Chromatic Aberration.
                Powered by Babylon.js, Three.js, and Unity MCP integration.
            </p>
            <p style="color: rgba(255,255,255,0.5);">
                ¬© 2025 Blaze Sports Intel ‚Ä¢ Advanced Graphics Pipeline ‚Ä¢ Professional 3D Platform
            </p>
        </div>
    </footer>

    <script>
        console.log('üî• Blaze Professional 3D Platform Initializing...');
        console.log('‚úÖ Advanced Shader Pipeline Ready');
        console.log('‚úÖ Unity MCP Integration Architecture Loaded');

        // Initialize Main Hero Canvas with Babylon.js Advanced Features
        (function initHeroCanvas() {
            const canvas = document.getElementById('mainCanvas');
            const engine = new BABYLON.Engine(canvas, true, {
                preserveDrawingBuffer: true,
                stencil: true,
                antialias: true
            });

            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.04, 0.04, 0.06, 1);

            // Camera setup
            const camera = new BABYLON.ArcRotateCamera(
                'camera',
                Math.PI / 4,
                Math.PI / 3,
                15,
                BABYLON.Vector3.Zero(),
                scene
            );
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 8;
            camera.upperRadiusLimit = 30;

            // Advanced lighting
            const hemiLight = new BABYLON.HemisphericLight(
                'hemiLight',
                new BABYLON.Vector3(0, 1, 0),
                scene
            );
            hemiLight.intensity = 0.6;

            const dirLight = new BABYLON.DirectionalLight(
                'dirLight',
                new BABYLON.Vector3(-1, -2, -1),
                scene
            );
            dirLight.intensity = 0.8;
            dirLight.position = new BABYLON.Vector3(10, 15, 10);

            // Create 3D baseball with advanced materials
            const ball = BABYLON.MeshBuilder.CreateSphere('ball', {
                diameter: 1.5,
                segments: 32
            }, scene);

            const ballMaterial = new BABYLON.StandardMaterial('ballMat', scene);
            ballMaterial.diffuseColor = new BABYLON.Color3(1, 1, 1);
            ballMaterial.specularColor = new BABYLON.Color3(0.8, 0.8, 0.8);
            ballMaterial.emissiveColor = new BABYLON.Color3(0.1, 0.05, 0);
            ball.material = ballMaterial;

            // Create glowing particles
            const particleSystem = new BABYLON.ParticleSystem('particles', 2000, scene);
            particleSystem.particleTexture = new BABYLON.Texture(
                'https://raw.githubusercontent.com/BabylonJS/Babylon.js/master/packages/tools/playground/public/textures/flare.png',
                scene
            );

            particleSystem.emitter = ball;
            particleSystem.minEmitBox = new BABYLON.Vector3(-0.5, -0.5, -0.5);
            particleSystem.maxEmitBox = new BABYLON.Vector3(0.5, 0.5, 0.5);

            particleSystem.color1 = new BABYLON.Color4(1, 0.42, 0, 1);
            particleSystem.color2 = new BABYLON.Color4(0, 0.83, 1, 1);
            particleSystem.colorDead = new BABYLON.Color4(0, 0, 0, 0);

            particleSystem.minSize = 0.05;
            particleSystem.maxSize = 0.15;
            particleSystem.minLifeTime = 0.5;
            particleSystem.maxLifeTime = 1.5;
            particleSystem.emitRate = 300;

            particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
            particleSystem.gravity = new BABYLON.Vector3(0, -1, 0);
            particleSystem.direction1 = new BABYLON.Vector3(-1, 1, -1);
            particleSystem.direction2 = new BABYLON.Vector3(1, 1, 1);

            particleSystem.minEmitPower = 0.5;
            particleSystem.maxEmitPower = 1.5;
            particleSystem.updateSpeed = 0.01;

            particleSystem.start();

            // Add post-processing pipeline
            const pipeline = new BABYLON.DefaultRenderingPipeline(
                'defaultPipeline',
                true,
                scene,
                [camera]
            );

            // Enable Bloom
            pipeline.bloomEnabled = true;
            pipeline.bloomThreshold = 0.5;
            pipeline.bloomWeight = 0.6;
            pipeline.bloomKernel = 64;
            pipeline.bloomScale = 0.5;

            // Enable chromatic aberration
            pipeline.chromaticAberrationEnabled = true;
            pipeline.chromaticAberration.aberrationAmount = 30;

            // Animation
            let alpha = 0;
            scene.registerBeforeRender(() => {
                alpha += 0.01;
                ball.position.y = Math.sin(alpha) * 2;
                ball.position.x = Math.cos(alpha * 0.5) * 3;
                ball.rotation.x += 0.02;
                ball.rotation.y += 0.03;
            });

            engine.runRenderLoop(() => {
                scene.render();
            });

            window.addEventListener('resize', () => {
                engine.resize();
            });

            console.log('‚úÖ Hero canvas with advanced Babylon.js rendering initialized');
        })();

        // ========================================
        // SHADER VISUALIZATION 1: BLOOM
        // ========================================
        const bloomViz = (function() {
            const canvas = document.getElementById('bloomCanvas');
            if (!canvas) return {};

            const engine = new BABYLON.Engine(canvas, true, { antialias: true });
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.02, 0.02, 0.05, 1);

            // Camera
            const camera = new BABYLON.ArcRotateCamera('camera', Math.PI / 4, Math.PI / 3, 20, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 10;
            camera.upperRadiusLimit = 40;

            // Lights
            const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.5;

            const dirLight = new BABYLON.DirectionalLight('dirLight', new BABYLON.Vector3(-1, -2, -1), scene);
            dirLight.intensity = 0.7;

            // Create stadium lights (bright emissive objects for bloom)
            const stadiumLights = [];
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const x = Math.cos(angle) * 8;
                const z = Math.sin(angle) * 8;

                const lightSphere = BABYLON.MeshBuilder.CreateSphere('light' + i, { diameter: 0.8 }, scene);
                lightSphere.position = new BABYLON.Vector3(x, 5, z);

                const mat = new BABYLON.StandardMaterial('lightMat' + i, scene);
                mat.emissiveColor = new BABYLON.Color3(1, 0.9, 0.7);
                mat.disableLighting = true;
                lightSphere.material = mat;

                stadiumLights.push(lightSphere);
            }

            // Create baseball diamond
            const diamond = BABYLON.MeshBuilder.CreateDisc('diamond', { radius: 6, tessellation: 4 }, scene);
            diamond.rotation.x = Math.PI / 2;
            const diamondMat = new BABYLON.StandardMaterial('diamondMat', scene);
            diamondMat.diffuseColor = new BABYLON.Color3(0.2, 0.6, 0.2);
            diamond.material = diamondMat;

            // Create bases with bright materials
            const basePositions = [
                [0, 0.1, -4], [4, 0.1, 0], [0, 0.1, 4], [-4, 0.1, 0]
            ];
            basePositions.forEach((pos, i) => {
                const base = BABYLON.MeshBuilder.CreateBox('base' + i, { size: 0.8 }, scene);
                base.position = new BABYLON.Vector3(pos[0], pos[1], pos[2]);
                const baseMat = new BABYLON.StandardMaterial('baseMat' + i, scene);
                baseMat.emissiveColor = new BABYLON.Color3(1, 1, 1);
                base.material = baseMat;
            });

            // Setup bloom pipeline
            const pipeline = new BABYLON.DefaultRenderingPipeline('pipeline', true, scene, [camera]);
            pipeline.bloomEnabled = true;
            pipeline.bloomThreshold = 0.5;
            pipeline.bloomWeight = 0.6;
            pipeline.bloomKernel = 64;
            pipeline.bloomScale = 0.5;

            // Animation
            let alpha = 0;
            scene.registerBeforeRender(() => {
                alpha += 0.01;
                stadiumLights.forEach((light, i) => {
                    const offset = (i / 8) * Math.PI * 2;
                    light.position.y = 5 + Math.sin(alpha + offset) * 0.5;
                });
            });

            engine.runRenderLoop(() => scene.render());
            window.addEventListener('resize', () => engine.resize());

            console.log('‚úÖ Bloom visualization initialized');

            return {
                pipeline,
                setIntensity: (weight) => {
                    pipeline.bloomWeight = weight;
                    console.log('Bloom weight set to:', weight);
                },
                toggle: () => {
                    pipeline.bloomEnabled = !pipeline.bloomEnabled;
                    console.log('Bloom enabled:', pipeline.bloomEnabled);
                }
            };
        })();

        window.setBloomIntensity = (intensity) => {
            if (bloomViz.setIntensity) bloomViz.setIntensity(intensity);
        };
        window.toggleBloom = () => {
            if (bloomViz.toggle) bloomViz.toggle();
        };

        // ========================================
        // SHADER VISUALIZATION 2: SSAO
        // ========================================
        const ssaoViz = (function() {
            const canvas = document.getElementById('ssaoCanvas');
            if (!canvas) return {};

            const engine = new BABYLON.Engine(canvas, true, { antialias: true });
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.12, 1);

            const camera = new BABYLON.ArcRotateCamera('camera', Math.PI / 4, Math.PI / 3, 15, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);

            const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.8;

            // Create player models (cylinders representing players)
            const playerPositions = [
                [0, 1, 0], [-3, 1, -2], [3, 1, -2], [-3, 1, 2], [3, 1, 2]
            ];

            playerPositions.forEach((pos, i) => {
                const player = BABYLON.MeshBuilder.CreateCylinder('player' + i, {
                    height: 2,
                    diameter: 0.6
                }, scene);
                player.position = new BABYLON.Vector3(pos[0], pos[1], pos[2]);

                const mat = new BABYLON.StandardMaterial('playerMat' + i, scene);
                mat.diffuseColor = new BABYLON.Color3(0.8, 0.4, 0.1);
                player.material = mat;

                // Add head
                const head = BABYLON.MeshBuilder.CreateSphere('head' + i, { diameter: 0.5 }, scene);
                head.position = new BABYLON.Vector3(pos[0], pos[1] + 1.5, pos[2]);
                head.material = mat;
            });

            // Ground plane
            const ground = BABYLON.MeshBuilder.CreateGround('ground', { width: 20, height: 20 }, scene);
            const groundMat = new BABYLON.StandardMaterial('groundMat', scene);
            groundMat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
            ground.material = groundMat;

            // Setup SSAO pipeline
            const pipeline = new BABYLON.DefaultRenderingPipeline('pipeline', true, scene, [camera]);

            if (BABYLON.SSAORenderingPipeline) {
                const ssaoRatio = {
                    ssaoRatio: 0.5,
                    combineRatio: 1.0
                };
                const ssao = new BABYLON.SSAORenderingPipeline('ssao', scene, ssaoRatio, [camera]);
                ssao.radius = 1.0;
                ssao.totalStrength = 1.3;
                ssao.base = 0.1;

                console.log('‚úÖ SSAO visualization initialized');

                return {
                    ssao,
                    setRadius: (radius) => {
                        ssao.radius = radius;
                        console.log('SSAO radius set to:', radius);
                    },
                    toggle: () => {
                        ssao.isEnabled = !ssao.isEnabled;
                        console.log('SSAO enabled:', ssao.isEnabled);
                    }
                };
            }

            engine.runRenderLoop(() => scene.render());
            window.addEventListener('resize', () => engine.resize());

            return {};
        })();

        window.setSSAORadius = (radius) => {
            if (ssaoViz.setRadius) ssaoViz.setRadius(radius);
        };
        window.toggleSSAO = () => {
            if (ssaoViz.toggle) ssaoViz.toggle();
        };

        // ========================================
        // SHADER VISUALIZATION 3: MOTION BLUR
        // ========================================
        const motionBlurViz = (function() {
            const canvas = document.getElementById('motionBlurCanvas');
            if (!canvas) return {};

            const engine = new BABYLON.Engine(canvas, true, { antialias: true });
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.08, 1);

            const camera = new BABYLON.ArcRotateCamera('camera', Math.PI / 4, Math.PI / 3, 25, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);

            const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 1.0;

            // Create fast-moving baseball
            const ball = BABYLON.MeshBuilder.CreateSphere('ball', { diameter: 1 }, scene);
            const ballMat = new BABYLON.StandardMaterial('ballMat', scene);
            ballMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
            ballMat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            ball.material = ballMat;

            // Create trajectory path
            const points = [];
            for (let i = 0; i < 50; i++) {
                const t = i / 50;
                const x = (t - 0.5) * 20;
                const y = -4 * (x * x / 100) + 3;
                const z = 0;
                points.push(new BABYLON.Vector3(x, y, z));
            }

            const path = BABYLON.MeshBuilder.CreateLines('path', { points }, scene);
            path.color = new BABYLON.Color3(1, 0.42, 0);

            // Setup motion blur
            const pipeline = new BABYLON.DefaultRenderingPipeline('pipeline', true, scene, [camera]);
            pipeline.motionBlurEnabled = true;
            pipeline.motionStrength = 1.0;
            pipeline.motionBlurSamples = 32;

            // Animation
            let pathIndex = 0;
            scene.registerBeforeRender(() => {
                pathIndex = (pathIndex + 0.5) % points.length;
                const currentIndex = Math.floor(pathIndex);
                ball.position = points[currentIndex].clone();
            });

            engine.runRenderLoop(() => scene.render());
            window.addEventListener('resize', () => engine.resize());

            console.log('‚úÖ Motion blur visualization initialized');

            return {
                pipeline,
                setAmount: (strength) => {
                    pipeline.motionStrength = strength;
                    console.log('Motion blur strength set to:', strength);
                },
                toggle: () => {
                    pipeline.motionBlurEnabled = !pipeline.motionBlurEnabled;
                    console.log('Motion blur enabled:', pipeline.motionBlurEnabled);
                }
            };
        })();

        window.setMotionBlur = (amount) => {
            if (motionBlurViz.setAmount) motionBlurViz.setAmount(amount);
        };
        window.toggleMotionBlur = () => {
            if (motionBlurViz.toggle) motionBlurViz.toggle();
        };

        // ========================================
        // SHADER VISUALIZATION 4: RIM LIGHTING
        // ========================================
        const rimViz = (function() {
            const canvas = document.getElementById('rimCanvas');
            if (!canvas) return {};

            const engine = new BABYLON.Engine(canvas, true, { antialias: true });
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.02, 0.02, 0.02, 1);

            const camera = new BABYLON.ArcRotateCamera('camera', Math.PI / 4, Math.PI / 3, 12, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);

            // Dramatic lighting for rim effect
            const backLight = new BABYLON.DirectionalLight('backLight', new BABYLON.Vector3(0, 0, 1), scene);
            backLight.intensity = 2.0;
            backLight.position = new BABYLON.Vector3(0, 5, -10);

            // Create player model
            const player = BABYLON.MeshBuilder.CreateCylinder('player', { height: 2.5, diameter: 0.8 }, scene);
            player.position.y = 1.25;

            const head = BABYLON.MeshBuilder.CreateSphere('head', { diameter: 0.6 }, scene);
            head.position.y = 3;

            // Rim lighting material using Fresnel
            const rimMat = new BABYLON.StandardMaterial('rimMat', scene);
            rimMat.diffuseColor = new BABYLON.Color3(0.8, 0.4, 0.1);
            rimMat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);

            // Fresnel for rim lighting effect
            rimMat.emissiveFresnelParameters = new BABYLON.FresnelParameters();
            rimMat.emissiveFresnelParameters.bias = 0.2;
            rimMat.emissiveFresnelParameters.power = 2;
            rimMat.emissiveFresnelParameters.leftColor = BABYLON.Color3.Black();
            rimMat.emissiveFresnelParameters.rightColor = new BABYLON.Color3(1, 0.42, 0);

            player.material = rimMat;
            head.material = rimMat;

            // Rotation animation
            let alpha = 0;
            scene.registerBeforeRender(() => {
                alpha += 0.01;
                player.rotation.y = alpha;
                head.rotation.y = alpha;
            });

            engine.runRenderLoop(() => scene.render());
            window.addEventListener('resize', () => engine.resize());

            console.log('‚úÖ Rim lighting visualization initialized');

            return {
                material: rimMat,
                setColor: (color) => {
                    const colors = {
                        orange: new BABYLON.Color3(1, 0.42, 0),
                        cyan: new BABYLON.Color3(0, 0.83, 1),
                        purple: new BABYLON.Color3(0.66, 0.33, 0.97)
                    };
                    rimMat.emissiveFresnelParameters.rightColor = colors[color] || colors.orange;
                    console.log('Rim color set to:', color);
                },
                toggle: () => {
                    rimMat.emissiveFresnelParameters.isEnabled = !rimMat.emissiveFresnelParameters.isEnabled;
                    console.log('Rim lighting enabled:', rimMat.emissiveFresnelParameters.isEnabled);
                }
            };
        })();

        window.setRimColor = (color) => {
            if (rimViz.setColor) rimViz.setColor(color);
        };
        window.toggleRim = () => {
            if (rimViz.toggle) rimViz.toggle();
        };

        // ========================================
        // SHADER VISUALIZATION 5: DEPTH OF FIELD
        // ========================================
        const dofViz = (function() {
            const canvas = document.getElementById('dofCanvas');
            if (!canvas) return {};

            const engine = new BABYLON.Engine(canvas, true, { antialias: true });
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.08, 0.08, 0.1, 1);

            const camera = new BABYLON.ArcRotateCamera('camera', Math.PI / 4, Math.PI / 3, 20, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);

            const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 1.0;

            // Create scene with multiple depth planes
            const depths = [-8, -4, 0, 4, 8];
            depths.forEach((z, i) => {
                const box = BABYLON.MeshBuilder.CreateBox('box' + i, { size: 2 }, scene);
                box.position = new BABYLON.Vector3(0, 0, z);

                const mat = new BABYLON.StandardMaterial('mat' + i, scene);
                mat.diffuseColor = new BABYLON.Color3(
                    0.5 + i * 0.1,
                    0.3,
                    0.8 - i * 0.1
                );
                box.material = mat;

                box.rotation.y = i * 0.3;
            });

            // Setup DOF pipeline
            const pipeline = new BABYLON.DefaultRenderingPipeline('pipeline', true, scene, [camera]);
            pipeline.depthOfFieldEnabled = true;
            pipeline.depthOfFieldBlurLevel = BABYLON.DepthOfFieldEffectBlurLevel.Medium;
            pipeline.depthOfField.focalLength = 150;
            pipeline.depthOfField.fStop = 1.4;
            pipeline.depthOfField.focusDistance = 5000;

            engine.runRenderLoop(() => scene.render());
            window.addEventListener('resize', () => engine.resize());

            console.log('‚úÖ Depth of field visualization initialized');

            return {
                pipeline,
                setFocus: (distance) => {
                    pipeline.depthOfField.focusDistance = distance * 1000;
                    console.log('DOF focus distance set to:', distance);
                },
                toggle: () => {
                    pipeline.depthOfFieldEnabled = !pipeline.depthOfFieldEnabled;
                    console.log('DOF enabled:', pipeline.depthOfFieldEnabled);
                }
            };
        })();

        window.setDOFFocus = (distance) => {
            if (dofViz.setFocus) dofViz.setFocus(distance);
        };
        window.toggleDOF = () => {
            if (dofViz.toggle) dofViz.toggle();
        };

        // ========================================
        // SHADER VISUALIZATION 6: CHROMATIC ABERRATION
        // ========================================
        const chromaticViz = (function() {
            const canvas = document.getElementById('chromaticCanvas');
            if (!canvas) return {};

            const engine = new BABYLON.Engine(canvas, true, { antialias: true });
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.08, 1);

            const camera = new BABYLON.ArcRotateCamera('camera', Math.PI / 4, Math.PI / 3, 15, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);

            const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 1.2;

            // Create colorful scene for chromatic aberration
            const sphere = BABYLON.MeshBuilder.CreateSphere('sphere', { diameter: 3 }, scene);
            sphere.position.y = 2;

            const sphereMat = new BABYLON.StandardMaterial('sphereMat', scene);
            sphereMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
            sphereMat.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            sphere.material = sphereMat;

            // Create colorful boxes
            const colors = [
                [1, 0, 0], [0, 1, 0], [0, 0, 1],
                [1, 1, 0], [1, 0, 1], [0, 1, 1]
            ];

            colors.forEach((color, i) => {
                const angle = (i / colors.length) * Math.PI * 2;
                const x = Math.cos(angle) * 5;
                const z = Math.sin(angle) * 5;

                const box = BABYLON.MeshBuilder.CreateBox('box' + i, { size: 1 }, scene);
                box.position = new BABYLON.Vector3(x, 0.5, z);

                const mat = new BABYLON.StandardMaterial('boxMat' + i, scene);
                mat.diffuseColor = new BABYLON.Color3(color[0], color[1], color[2]);
                mat.emissiveColor = new BABYLON.Color3(color[0] * 0.3, color[1] * 0.3, color[2] * 0.3);
                box.material = mat;
            });

            // Setup chromatic aberration
            const pipeline = new BABYLON.DefaultRenderingPipeline('pipeline', true, scene, [camera]);
            pipeline.chromaticAberrationEnabled = true;
            pipeline.chromaticAberration.aberrationAmount = 30;
            pipeline.chromaticAberration.radialIntensity = 1.0;

            // Rotation animation
            let alpha = 0;
            scene.registerBeforeRender(() => {
                alpha += 0.01;
                sphere.rotation.y = alpha;
            });

            engine.runRenderLoop(() => scene.render());
            window.addEventListener('resize', () => engine.resize());

            console.log('‚úÖ Chromatic aberration visualization initialized');

            return {
                pipeline,
                setAmount: (amount) => {
                    pipeline.chromaticAberration.aberrationAmount = amount;
                    console.log('Chromatic aberration amount set to:', amount);
                },
                toggle: () => {
                    pipeline.chromaticAberrationEnabled = !pipeline.chromaticAberrationEnabled;
                    console.log('Chromatic aberration enabled:', pipeline.chromaticAberrationEnabled);
                }
            };
        })();

        window.setChromaticAmount = (amount) => {
            if (chromaticViz.setAmount) chromaticViz.setAmount(amount);
        };
        window.toggleChromatic = () => {
            if (chromaticViz.toggle) chromaticViz.toggle();
        };

        // Performance monitoring
        let lastTime = performance.now();
        let frameCount = 0;
        function updatePerformance() {
            frameCount++;
            const now = performance.now();
            const delta = now - lastTime;

            if (delta >= 1000) {
                const fps = Math.round((frameCount * 1000) / delta);
                document.getElementById('perfFPS').textContent = fps;
                document.getElementById('perfFPS').className = 'perf-value ' +
                    (fps >= 55 ? 'good' : fps >= 30 ? 'warning' : '');

                const renderTime = (delta / frameCount).toFixed(1);
                document.getElementById('perfRenderTime').textContent = renderTime + 'ms';

                frameCount = 0;
                lastTime = now;
            }

            requestAnimationFrame(updatePerformance);
        }
        updatePerformance();

        console.log('üî• Professional 3D Platform Loaded Successfully');
        console.log('üìä 6 Advanced Shader Techniques Active');
        console.log('ü§ñ Unity MCP Integration Ready');
        console.log('‚ö° Performance Monitoring Active');
    </script>
</body>
</html>