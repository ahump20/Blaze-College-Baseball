<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸ”¥ Blaze Graphics Performance Benchmark Suite</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0f0f0f;
            color: #ffffff;
            padding: 20px;
        }

        #canvas3d {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .controls {
            position: relative;
            z-index: 10;
            background: rgba(26, 26, 26, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 24px;
            max-width: 800px;
            margin: 0 auto 20px;
        }

        .results {
            position: relative;
            z-index: 10;
            background: rgba(26, 26, 26, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 24px;
            max-width: 800px;
            margin: 0 auto;
            display: none;
        }

        .results.visible {
            display: block;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #ff6b35, #f7931e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 24px;
        }

        .device-info {
            background: rgba(255, 107, 53, 0.1);
            border: 1px solid rgba(255, 107, 53, 0.3);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 24px;
        }

        .device-info h2 {
            font-size: 16px;
            margin-bottom: 12px;
            color: #ff6b35;
        }

        .device-info p {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 6px;
        }

        .test-config {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }

        .config-item label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .config-item select,
        .config-item input {
            width: 100%;
            background: rgba(42, 42, 42, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            color: white;
            font-size: 14px;
        }

        button {
            width: 100%;
            background: linear-gradient(135deg, #ff6b35, #f7931e);
            border: none;
            border-radius: 10px;
            padding: 16px 32px;
            color: white;
            font-weight: 700;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 16px;
        }

        button:hover {
            transform: scale(1.02);
            box-shadow: 0 8px 24px rgba(255, 107, 53, 0.5);
        }

        button:active {
            transform: scale(0.98);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            text-align: center;
            padding: 20px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.6);
        }

        .progress {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 12px;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff6b35, #f7931e);
            width: 0%;
            transition: width 0.3s;
        }

        .results-grid {
            display: grid;
            gap: 16px;
        }

        .result-card {
            background: rgba(42, 42, 42, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
        }

        .result-card h3 {
            font-size: 18px;
            margin-bottom: 16px;
            color: #ff6b35;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .metric-row:last-child {
            border-bottom: none;
        }

        .metric-label {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.6);
        }

        .metric-value {
            font-size: 14px;
            font-weight: 600;
            color: white;
        }

        .metric-value.good {
            color: #28a745;
        }

        .metric-value.warning {
            color: #ffc107;
        }

        .metric-value.poor {
            color: #dc3545;
        }

        .export-btn {
            margin-top: 20px;
            background: rgba(42, 42, 42, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .export-btn:hover {
            background: rgba(52, 52, 52, 0.9);
        }

        .fps-display {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(26, 26, 26, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px;
            min-width: 200px;
        }

        .fps-value {
            font-size: 48px;
            font-weight: 700;
            line-height: 1;
            margin-bottom: 8px;
        }

        .fps-label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        @media (max-width: 768px) {
            .controls, .results {
                padding: 16px;
            }

            .test-config {
                grid-template-columns: 1fr;
            }

            .fps-display {
                top: 10px;
                right: 10px;
                padding: 12px;
                min-width: 150px;
            }

            .fps-value {
                font-size: 36px;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas3d"></canvas>

    <div class="fps-display">
        <div class="fps-value" id="currentFPS">--</div>
        <div class="fps-label">Current FPS</div>
    </div>

    <div class="controls" id="controls">
        <h1>ðŸ”¥ Graphics Performance Benchmark</h1>
        <p class="subtitle">Automated performance testing for Blaze Graphics Engine V5</p>

        <div class="device-info">
            <h2>Detected Device Configuration</h2>
            <p id="deviceClass">Device Class: Detecting...</p>
            <p id="deviceCPU">CPU: Detecting...</p>
            <p id="deviceGPU">GPU: Detecting...</p>
            <p id="deviceMemory">Memory: Detecting...</p>
            <p id="deviceScreen">Screen: Detecting...</p>
        </div>

        <div class="test-config">
            <div class="config-item">
                <label>Particle Count</label>
                <select id="particleCount">
                    <option value="25000">25,000 particles</option>
                    <option value="50000">50,000 particles</option>
                    <option value="100000" selected>100,000 particles</option>
                    <option value="150000">150,000 particles</option>
                    <option value="200000">200,000 particles</option>
                </select>
            </div>

            <div class="config-item">
                <label>Test Duration</label>
                <select id="testDuration">
                    <option value="30">30 seconds</option>
                    <option value="60" selected>60 seconds</option>
                    <option value="120">120 seconds</option>
                </select>
            </div>

            <div class="config-item">
                <label>Interaction Mode</label>
                <select id="interactionMode">
                    <option value="idle">Idle (Static)</option>
                    <option value="simulated" selected>Simulated Movement</option>
                    <option value="manual">Manual Mouse Movement</option>
                </select>
            </div>

            <div class="config-item">
                <label>Test Runs</label>
                <select id="testRuns">
                    <option value="1" selected>1 run</option>
                    <option value="3">3 runs (averaged)</option>
                    <option value="5">5 runs (averaged)</option>
                </select>
            </div>
        </div>

        <button id="startBtn">Start Benchmark</button>

        <div id="statusDiv" style="display: none;">
            <div class="status" id="statusText">Preparing benchmark...</div>
            <div class="progress">
                <div class="progress-bar" id="progressBar"></div>
            </div>
        </div>
    </div>

    <div class="results" id="results">
        <h1>ðŸ“Š Benchmark Results</h1>
        <p class="subtitle" id="resultsSubtitle">Completed</p>

        <div class="results-grid" id="resultsGrid"></div>

        <button class="export-btn" id="exportBtn">Export Results as JSON</button>
        <button id="rerunBtn">Run Another Test</button>
    </div>

    <script>
        // Configuration
        let CONFIG = {
            PARTICLE_COUNT: 100000,
            NODE_COUNT: 60,
            CONNECTION_COUNT: 100
        };

        // Device detection
        const DEVICE_INFO = {
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            cores: navigator.hardwareConcurrency || 4,
            memory: navigator.deviceMemory || 4,
            pixelRatio: window.devicePixelRatio || 1,
            screenWidth: window.screen.width,
            screenHeight: window.screen.height,
            viewportWidth: window.innerWidth,
            viewportHeight: window.innerHeight
        };

        // Detect device class
        function detectDeviceClass() {
            const isMobile = /iPhone|iPad|iPod|Android/i.test(DEVICE_INFO.userAgent);
            const isTablet = /iPad|Android.*Tablet/i.test(DEVICE_INFO.userAgent) ||
                           (isMobile && Math.min(DEVICE_INFO.screenWidth, DEVICE_INFO.screenHeight) >= 768);

            if (isMobile && !isTablet) {
                // Mobile classification
                const isHighEnd = DEVICE_INFO.cores >= 6 && DEVICE_INFO.memory >= 4;
                return isHighEnd ? 'mobile-high' : 'mobile-low';
            } else if (isTablet) {
                return 'tablet';
            } else {
                // Desktop classification
                const isHighEnd = DEVICE_INFO.cores >= 8 && DEVICE_INFO.memory >= 16;
                return isHighEnd ? 'desktop-high' : 'desktop-mid';
            }
        }

        // Get WebGL GPU info
        function getGPUInfo() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!gl) return 'Unknown';

                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                if (debugInfo) {
                    return gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                }
                return 'WebGL Available';
            } catch (e) {
                return 'Unknown';
            }
        }

        // Update device info display
        function updateDeviceInfo() {
            const deviceClass = detectDeviceClass();
            const gpuInfo = getGPUInfo();

            document.getElementById('deviceClass').textContent =
                `Device Class: ${deviceClass.replace('-', ' ').toUpperCase()}`;
            document.getElementById('deviceCPU').textContent =
                `CPU: ${DEVICE_INFO.cores} cores`;
            document.getElementById('deviceGPU').textContent =
                `GPU: ${gpuInfo}`;
            document.getElementById('deviceMemory').textContent =
                `Memory: ${DEVICE_INFO.memory}GB`;
            document.getElementById('deviceScreen').textContent =
                `Screen: ${DEVICE_INFO.screenWidth}x${DEVICE_INFO.screenHeight} @ ${DEVICE_INFO.pixelRatio}x`;
        }

        // Three.js scene
        let scene, camera, renderer, particles, dataNodes = [], connections = [];
        let mouseX = 0, mouseY = 0;

        // Performance tracking
        let frameCount = 0;
        let lastTime = Date.now();
        let fpsHistory = [];
        let frameTimeHistory = [];
        let isRunning = false;

        // Initialize Three.js
        function initThreeJS() {
            const canvas = document.getElementById('canvas3d');

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0f0f0f, 0.0005);

            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                1,
                3000
            );
            camera.position.z = 1000;

            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                alpha: false,
                powerPreference: 'high-performance'
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            const pointLight1 = new THREE.PointLight(0xff6b35, 1, 1000);
            pointLight1.position.set(500, 500, 500);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xf7931e, 0.8, 1000);
            pointLight2.position.set(-500, -500, -500);
            scene.add(pointLight2);

            createParticles();
            createDataNodes();
            createConnections();

            document.addEventListener('mousemove', onMouseMove);
            window.addEventListener('resize', onWindowResize);
        }

        // Create particles
        function createParticles() {
            if (particles) {
                scene.remove(particles);
                particles.geometry.dispose();
                particles.material.dispose();
            }

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(CONFIG.PARTICLE_COUNT * 3);
            const colors = new Float32Array(CONFIG.PARTICLE_COUNT * 3);

            const color1 = new THREE.Color(0xff6b35);
            const color2 = new THREE.Color(0xf7931e);

            for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
                const i3 = i * 3;

                positions[i3] = (Math.random() - 0.5) * 2000;
                positions[i3 + 1] = (Math.random() - 0.5) * 2000;
                positions[i3 + 2] = (Math.random() - 0.5) * 2000;

                const mixColor = Math.random() > 0.5 ? color1 : color2;
                colors[i3] = mixColor.r;
                colors[i3 + 1] = mixColor.g;
                colors[i3 + 2] = mixColor.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // Create data nodes
        function createDataNodes() {
            dataNodes.forEach(node => scene.remove(node));
            dataNodes = [];

            const geometry = new THREE.SphereGeometry(8, 16, 16);

            for (let i = 0; i < CONFIG.NODE_COUNT; i++) {
                const material = new THREE.MeshPhongMaterial({
                    color: i % 2 === 0 ? 0xff6b35 : 0xf7931e,
                    emissive: i % 2 === 0 ? 0xff6b35 : 0xf7931e,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.9
                });

                const node = new THREE.Mesh(geometry, material);

                const radius = 400 + Math.random() * 400;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;

                node.position.x = radius * Math.sin(phi) * Math.cos(theta);
                node.position.y = radius * Math.sin(phi) * Math.sin(theta);
                node.position.z = radius * Math.cos(phi);

                node.userData = {
                    originalPosition: node.position.clone(),
                    phase: Math.random() * Math.PI * 2,
                    speed: 0.5 + Math.random() * 0.5
                };

                scene.add(node);
                dataNodes.push(node);
            }
        }

        // Create connections
        function createConnections() {
            connections.forEach(conn => scene.remove(conn.line));
            connections = [];

            for (let i = 0; i < CONFIG.CONNECTION_COUNT; i++) {
                const node1 = dataNodes[Math.floor(Math.random() * dataNodes.length)];
                const node2 = dataNodes[Math.floor(Math.random() * dataNodes.length)];

                if (node1 !== node2) {
                    const distance = node1.position.distanceTo(node2.position);

                    if (distance < 700) {
                        const geometry = new THREE.BufferGeometry().setFromPoints([
                            node1.position.clone(),
                            node2.position.clone()
                        ]);

                        const material = new THREE.LineBasicMaterial({
                            color: 0x5555ff,
                            transparent: true,
                            opacity: 0.15,
                            blending: THREE.AdditiveBlending
                        });

                        const line = new THREE.Line(geometry, material);
                        scene.add(line);

                        connections.push({ line, node1, node2 });
                    }
                }
            }
        }

        // Animation loop
        function animate() {
            if (!isRunning) return;
            requestAnimationFrame(animate);

            const now = performance.now();
            const deltaTime = now - lastTime;

            // Track frame times
            frameTimeHistory.push(deltaTime);
            if (frameTimeHistory.length > 300) {
                frameTimeHistory.shift();
            }

            // Update FPS counter
            frameCount++;
            if (now - lastTime >= 1000) {
                const currentFPS = frameCount;
                fpsHistory.push(currentFPS);

                document.getElementById('currentFPS').textContent = currentFPS;
                document.getElementById('currentFPS').className = 'fps-value ' +
                    (currentFPS >= 60 ? 'good' : currentFPS >= 30 ? 'warning' : 'poor');

                frameCount = 0;
                lastTime = now;
            }

            const time = Date.now() * 0.0005;

            // Animate particles
            if (particles) {
                particles.rotation.x += 0.0002;
                particles.rotation.y += 0.0003;
            }

            // Animate data nodes
            dataNodes.forEach((node) => {
                const userData = node.userData;
                const angle = time * userData.speed + userData.phase;

                node.position.x = userData.originalPosition.x + Math.cos(angle) * 30;
                node.position.y = userData.originalPosition.y + Math.sin(angle) * 30;
                node.position.z = userData.originalPosition.z + Math.sin(angle * 0.5) * 20;

                node.rotation.x += 0.005;
                node.rotation.y += 0.003;

                const scale = 1 + Math.sin(time * 2 + userData.phase) * 0.1;
                node.scale.set(scale, scale, scale);
            });

            // Update connections
            connections.forEach(conn => {
                const positions = conn.line.geometry.attributes.position.array;
                positions[0] = conn.node1.position.x;
                positions[1] = conn.node1.position.y;
                positions[2] = conn.node1.position.z;
                positions[3] = conn.node2.position.x;
                positions[4] = conn.node2.position.y;
                positions[5] = conn.node2.position.z;
                conn.line.geometry.attributes.position.needsUpdate = true;
            });

            // Camera movement
            camera.position.x += (mouseX - camera.position.x) * 0.02;
            camera.position.y += (-mouseY - camera.position.y) * 0.02;
            camera.lookAt(scene.position);

            renderer.render(scene, camera);
        }

        // Mouse move handler
        function onMouseMove(event) {
            mouseX = (event.clientX - window.innerWidth / 2) * 0.5;
            mouseY = (event.clientY - window.innerHeight / 2) * 0.5;
        }

        // Window resize handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Run benchmark
        async function runBenchmark(particleCount, duration, interactionMode, runNumber, totalRuns) {
            return new Promise((resolve) => {
                CONFIG.PARTICLE_COUNT = particleCount;

                // Reset metrics
                frameCount = 0;
                fpsHistory = [];
                frameTimeHistory = [];
                lastTime = Date.now();

                // Update status
                document.getElementById('statusText').textContent =
                    `Running benchmark ${runNumber}/${totalRuns} â€¢ ${(particleCount/1000).toFixed(0)}K particles â€¢ ${duration}s`;

                // Recreate scene with new particle count
                createParticles();

                // Simulate mouse movement if requested
                let simulationInterval = null;
                if (interactionMode === 'simulated') {
                    simulationInterval = setInterval(() => {
                        mouseX = Math.sin(Date.now() * 0.001) * 500;
                        mouseY = Math.cos(Date.now() * 0.001) * 500;
                    }, 50);
                }

                // Run test for specified duration
                isRunning = true;
                animate();

                setTimeout(() => {
                    isRunning = false;
                    if (simulationInterval) clearInterval(simulationInterval);

                    // Calculate statistics
                    const avgFPS = fpsHistory.reduce((a, b) => a + b, 0) / fpsHistory.length;
                    const minFPS = Math.min(...fpsHistory);
                    const maxFPS = Math.max(...fpsHistory);

                    // Calculate percentiles
                    const sortedFPS = [...fpsHistory].sort((a, b) => a - b);
                    const p1Index = Math.floor(sortedFPS.length * 0.01);
                    const p01Index = Math.floor(sortedFPS.length * 0.001);
                    const fps1Percent = sortedFPS[p1Index] || minFPS;
                    const fps01Percent = sortedFPS[p01Index] || minFPS;

                    // Frame time stats
                    const avgFrameTime = frameTimeHistory.reduce((a, b) => a + b, 0) / frameTimeHistory.length;
                    const sortedFrameTimes = [...frameTimeHistory].sort((a, b) => b - a);
                    const p99FrameTime = sortedFrameTimes[Math.floor(sortedFrameTimes.length * 0.01)];

                    // Memory usage (if available)
                    const memoryUsage = performance.memory ?
                        {
                            used: (performance.memory.usedJSHeapSize / 1048576).toFixed(2),
                            total: (performance.memory.totalJSHeapSize / 1048576).toFixed(2),
                            limit: (performance.memory.jsHeapSizeLimit / 1048576).toFixed(2)
                        } : null;

                    resolve({
                        particleCount,
                        duration,
                        interactionMode,
                        avgFPS: avgFPS.toFixed(2),
                        minFPS: minFPS.toFixed(2),
                        maxFPS: maxFPS.toFixed(2),
                        fps1Percent: fps1Percent.toFixed(2),
                        fps01Percent: fps01Percent.toFixed(2),
                        avgFrameTime: avgFrameTime.toFixed(2),
                        p99FrameTime: p99FrameTime ? p99FrameTime.toFixed(2) : 'N/A',
                        memoryUsage,
                        samples: fpsHistory.length
                    });
                }, duration * 1000);
            });
        }

        // Display results
        function displayResults(results) {
            const resultsGrid = document.getElementById('resultsGrid');
            resultsGrid.innerHTML = '';

            results.forEach((result, index) => {
                const card = document.createElement('div');
                card.className = 'result-card';

                const getFPSClass = (fps) => {
                    const fpsNum = parseFloat(fps);
                    return fpsNum >= 60 ? 'good' : fpsNum >= 30 ? 'warning' : 'poor';
                };

                card.innerHTML = `
                    <h3>Test ${index + 1}: ${(result.particleCount / 1000).toFixed(0)}K Particles</h3>

                    <div class="metric-row">
                        <span class="metric-label">Average FPS</span>
                        <span class="metric-value ${getFPSClass(result.avgFPS)}">${result.avgFPS}</span>
                    </div>

                    <div class="metric-row">
                        <span class="metric-label">1% Low FPS</span>
                        <span class="metric-value ${getFPSClass(result.fps1Percent)}">${result.fps1Percent}</span>
                    </div>

                    <div class="metric-row">
                        <span class="metric-label">0.1% Low FPS</span>
                        <span class="metric-value ${getFPSClass(result.fps01Percent)}">${result.fps01Percent}</span>
                    </div>

                    <div class="metric-row">
                        <span class="metric-label">Min / Max FPS</span>
                        <span class="metric-value">${result.minFPS} / ${result.maxFPS}</span>
                    </div>

                    <div class="metric-row">
                        <span class="metric-label">Avg Frame Time</span>
                        <span class="metric-value">${result.avgFrameTime} ms</span>
                    </div>

                    <div class="metric-row">
                        <span class="metric-label">99th Percentile Frame Time</span>
                        <span class="metric-value">${result.p99FrameTime} ms</span>
                    </div>

                    <div class="metric-row">
                        <span class="metric-label">Test Duration</span>
                        <span class="metric-value">${result.duration}s (${result.samples} samples)</span>
                    </div>

                    <div class="metric-row">
                        <span class="metric-label">Interaction Mode</span>
                        <span class="metric-value">${result.interactionMode}</span>
                    </div>

                    ${result.memoryUsage ? `
                    <div class="metric-row">
                        <span class="metric-label">Memory Usage</span>
                        <span class="metric-value">${result.memoryUsage.used} / ${result.memoryUsage.limit} MB</span>
                    </div>
                    ` : ''}
                `;

                resultsGrid.appendChild(card);
            });

            // Show results
            document.getElementById('controls').style.display = 'none';
            document.getElementById('results').classList.add('visible');
        }

        // Export results
        function exportResults(results) {
            const data = {
                timestamp: new Date().toISOString(),
                device: {
                    class: detectDeviceClass(),
                    userAgent: DEVICE_INFO.userAgent,
                    platform: DEVICE_INFO.platform,
                    cores: DEVICE_INFO.cores,
                    memory: DEVICE_INFO.memory,
                    gpu: getGPUInfo(),
                    screen: `${DEVICE_INFO.screenWidth}x${DEVICE_INFO.screenHeight}`,
                    pixelRatio: DEVICE_INFO.pixelRatio
                },
                results: results
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `blaze-benchmark-${detectDeviceClass()}-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', async () => {
            const particleCount = parseInt(document.getElementById('particleCount').value);
            const duration = parseInt(document.getElementById('testDuration').value);
            const interactionMode = document.getElementById('interactionMode').value;
            const runs = parseInt(document.getElementById('testRuns').value);

            document.getElementById('startBtn').disabled = true;
            document.getElementById('statusDiv').style.display = 'block';

            const results = [];

            for (let i = 0; i < runs; i++) {
                const progress = ((i + 1) / runs) * 100;
                document.getElementById('progressBar').style.width = progress + '%';

                const result = await runBenchmark(particleCount, duration, interactionMode, i + 1, runs);
                results.push(result);

                // Wait 2 seconds between runs
                if (i < runs - 1) {
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
            }

            displayResults(results);

            // Store results for export
            window.benchmarkResults = results;
        });

        document.getElementById('exportBtn').addEventListener('click', () => {
            if (window.benchmarkResults) {
                exportResults(window.benchmarkResults);
            }
        });

        document.getElementById('rerunBtn').addEventListener('click', () => {
            document.getElementById('results').classList.remove('visible');
            document.getElementById('controls').style.display = 'block';
            document.getElementById('statusDiv').style.display = 'none';
            document.getElementById('startBtn').disabled = false;
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('currentFPS').textContent = '--';
        });

        // Initialize
        updateDeviceInfo();
        initThreeJS();
    </script>
</body>
</html>
